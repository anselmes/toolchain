#!/bin/bash

# SPDX-License-Identifier: GPL-3.0
# Copyright (c) 2025 Schubert Anselme <schubert@anselm.es>

#
# buildimg - Docker Sandbox Management Script
#
# A utility script for managing a privileged Docker container sandbox environment
# for development and testing purposes. Supports initialization, shell access,
# command execution, and cleanup operations.
#
# Author: Schubert Anselme <schubert@anselm.es>
# Version: 1.0
# Dependencies: Docker
#

set -euo pipefail

# Configuration
readonly SCRIPT_NAME=$(basename "$0")
readonly CONTAINER_NAME="sandbox"
readonly CONTAINER_IMAGE="ghcr.io/labsonline/devcontainer/lang/rust:24.04"
readonly WORKSPACE_PATH="${HOME}/workspace"
readonly CONTAINER_WORKSPACE="/home/ubuntu/workspace"

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

#
# Print colored output messages
#
log_info() {
  echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
  echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
  echo -e "${RED}[ERROR]${NC} $1" >&2
}

#
# Display usage information and available options
#
help() {
    cat << EOF
Usage: ${SCRIPT_NAME} [OPTIONS]

A Docker sandbox management utility for development environments.

OPTIONS:
  --init       Create and start a new sandbox environment
  --shell      Enter an interactive shell in the sandbox
  --exec=CMD   Execute a specific command in the sandbox
  --cleanup    Stop and remove the sandbox environment
  --help       Show this help message

EXAMPLES:
  ${SCRIPT_NAME} --init                    # Create sandbox
  ${SCRIPT_NAME} --shell                   # Enter shell
  ${SCRIPT_NAME} --exec="cargo build"      # Run command
  ${SCRIPT_NAME} --cleanup                 # Clean up

NOTES:
  - The sandbox runs with privileged access
  - Host workspace is mounted at ${CONTAINER_WORKSPACE}
  - Container runs as root but commands execute as ubuntu user

EOF
}

#
# Check if Docker is available and running
#
check_docker() {
  if ! command -v docker &> /dev/null; then
    log_error "Docker is not installed or not in PATH"
    exit 1
  fi

  if ! docker info &> /dev/null; then
    log_error "Docker daemon is not running"
    exit 1
  fi
}

#
# Check if the sandbox container exists and is running
#
container_exists() {
  docker container inspect "${CONTAINER_NAME}" &> /dev/null
}

container_running() {
  [[ "$(docker container inspect -f '{{.State.Running}}' "${CONTAINER_NAME}" 2>/dev/null)" == "true" ]]
}

#
# Initialize and start the sandbox container
#
init_sandbox() {
  log_info "Checking Docker availability..."
  check_docker

  if container_exists; then
    if container_running; then
      log_warn "Sandbox container '${CONTAINER_NAME}' is already running"
      return 0
    else
      log_info "Removing existing stopped container..."
      docker container rm "${CONTAINER_NAME}" &> /dev/null || true
    fi
  fi

  log_info "Creating sandbox environment with image: ${CONTAINER_IMAGE}"

  # Verify workspace directory exists
  if [[ ! -d "${WORKSPACE_PATH}" ]]; then
    log_error "Workspace directory '${WORKSPACE_PATH}' does not exist"
    exit 1
  fi

  docker container run \
    --rm \
    --privileged \
    --detach \
    --interactive \
    --tty \
    --name "${CONTAINER_NAME}" \
    --user root \
    --cgroupns host \
    --volume /dev:/dev \
    --volume /sys/fs/cgroup:/sys/fs/cgroup:rw \
    --volume "${WORKSPACE_PATH}:${CONTAINER_WORKSPACE}" \
    --workdir "${CONTAINER_WORKSPACE}" \
    "${CONTAINER_IMAGE}" \
    /lib/systemd/systemd

  # Wait for container to be ready
  log_info "Waiting for container to be ready..."
  sleep 3

  if container_running; then
    log_info "Sandbox environment created successfully"
  else
    log_error "Failed to create sandbox environment"
    exit 1
  fi
}

#
# Enter an interactive shell in the sandbox
#
enter_shell() {
  check_docker

  if ! container_running; then
    log_error "Sandbox container is not running. Use --init to create it first."
    exit 1
  fi

  log_info "Entering sandbox shell..."
  docker container exec --user ubuntu --interactive --tty "${CONTAINER_NAME}" /bin/zsh -l
}

#
# Execute a command in the sandbox
#
execute_command() {
  local command="$1"

  check_docker

  if ! container_running; then
    log_error "Sandbox container is not running. Use --init to create it first."
    exit 1
  fi

  log_info "Executing command in sandbox: ${command}"
  docker container exec --user ubuntu "${CONTAINER_NAME}" /bin/bash -c "${command}"
}

#
# Clean up the sandbox environment
#
cleanup_sandbox() {
  check_docker

  if ! container_exists; then
    log_warn "No sandbox container found to clean up"
    return 0
  fi

  log_info "Cleaning up sandbox environment..."

  if container_running; then
    docker container stop "${CONTAINER_NAME}" &> /dev/null || true
    log_info "Sandbox container stopped successfully"
  else
    log_info "Container was already stopped"
  fi

  # Container is automatically removed due to --rm flag
  log_info "Sandbox environment cleaned up"
}

#
# Parse command line arguments
#
parse_arguments() {
  local init_flag=false
  local shell_flag=false
  local exec_command=""
  local cleanup_flag=false

  # Handle case where no arguments provided
  if [[ $# -eq 0 ]]; then
    help
    exit 0
  fi

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      --init)
        init_flag=true
        ;;
      --shell)
        shell_flag=true
        ;;
      --exec=*)
        exec_command="${1#*=}"
        if [[ -z "${exec_command}" ]]; then
          log_error "No command provided for --exec option"
          exit 1
        fi
        ;;
      --cleanup)
        cleanup_flag=true
        ;;
      --help|-h)
        help
        exit 0
        ;;
      *)
        log_error "Unknown option: $1"
        help
        exit 1
        ;;
    esac
    shift
  done

  # Execute based on flags (order matters)
  if [[ "${init_flag}" == true ]]; then
    init_sandbox
  fi

  if [[ "${shell_flag}" == true ]]; then
    enter_shell
  fi

  if [[ -n "${exec_command}" ]]; then
    execute_command "${exec_command}"
  fi

  if [[ "${cleanup_flag}" == true ]]; then
    cleanup_sandbox
  fi
}

#
# Main entry point
#
main() {
  parse_arguments "$@"
}

# Execute main function with all arguments
main "$@"
